// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

/**
 * @fileoverview Disallows usage of insecure protocols in URL strings
 */

"use strict";


//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
const DEFAULT_BLOCKLIST = [/^(ftp|http|telnet|ws):\/\//i];

const DEFAULT_EXCEPTIONS = [
  // TODO: add more typical false positives such as XML schemas after more testing
  /^http:(\/\/|\\u002f\\u002f)schemas\.microsoft\.com(\/\/|\\u002f\\u002f)?.*/i,
  /^http:(\/\/|\\u002f\\u002f)schemas\.openxmlformats\.org(\/\/|\\u002f\\u002f)?.*/i,
  /^http:(\/|\\u002f){2}localhost(:|\/|\\u002f)*/i,
];
// Flag that exempts file from warnings
let skipUpcomingLines = false;

// helper function to check if file/ line should get changed
function checkComment(node) {
  const comment = node.value;
  console.log("My comment: " + comment);
  if (comment.includes("DO NOT MODIFY") ||
      comment.includes("AUTOGENERATED") ||
      comment.includes("AUTO-GENERATED")
  ) {
    return true;
  }
  return false;
}
// If one of the first comments in the file indicates that the files shouldn't be changed.
// skip the upcoming lines.
function shouldExemptFile(context) {
  let sourceCode = context.getSourceCode();
  // Get all comments and max. check the first five comments
  const allComments = sourceCode.getAllComments();
  for (let i = 0; i < allComments.length && i < 5; i++) {
    // if true file shouldn't get changed
    if (checkComment(allComments[i])) {
      return true;
    }
  }
  return false;
}

function shouldFix(context, node) {
  let sourceCode = context.getSourceCode();
  let comments = sourceCode.getCommentsBefore(sourceCode.getText(node));
  // length of getBeforeComments is always 0
  for (let i = 0; i < comments.length && i < 2; i++) {
    // if true line shouldn't get changed
    if (checkComment(comments[i])) {
      return false;
    }
  }
  const text = node.parent
    ? sourceCode.getText(node.parent)
    : sourceCode.getText(node);
  const unfixablePattern = ["insecure", "Insecure", "xmlns"];
  for (let i = 0; i < unfixablePattern.length; i++) {
    const element = unfixablePattern[i];
    if (text.includes(element)) {
      return false;
    }
  }
    return true;
}

module.exports = {
  defaultBlocklist: DEFAULT_BLOCKLIST,
  defaultExceptions: DEFAULT_EXCEPTIONS,
  meta: {
    type: "suggestion",
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          blocklist: {
            type: "array",
            items: {
              type: "string",
            },
          },
          exceptions: {
            type: "array",
            items: {
              type: "string",
            },
          },
        },
        additionalProperties: false,
      },
    ],
    docs: {
      category: "Security",
      description:
        "Insecure protocols such as [HTTP](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) or [FTP](https://en.wikipedia.org/wiki/File_Transfer_Protocol) should be replaced by their encrypted counterparts ([HTTPS](https://en.wikipedia.org/wiki/HTTPS), [FTPS](https://en.wikipedia.org/wiki/FTPS)) to avoid sending (potentially sensitive) data over untrusted network in plaintext.",
      url:
        "https://github.com/microsoft/eslint-plugin-sdl/blob/master/docs/rules/no-insecure-url.md",
    },
    messages: {
      doNotUseInsecureUrl: "Do not use insecure URLs",
    },
  },
  create: function(context) {
    const options = context.options[0] || {};
    const blocklist = (options.blocklist || DEFAULT_BLOCKLIST).map(pattern => {
      return new RegExp(pattern, "i");
    });
    const exceptions = (options.exceptions || DEFAULT_EXCEPTIONS).map(
      pattern => {
        return new RegExp(pattern, "i");
      }
    );
    // Check first five comments and set flag if needed
    skipUpcomingLines = shouldExemptFile(context);
    function matches(patterns, value) {
      return (
        patterns.find(re => {
          return re.test(value);
        }) !== undefined
      );
    }

    return {
      Literal(node) {
        if (skipUpcomingLines) {
          //Do Nothing
        } else if (typeof node.value === "string") {
          // Add an exception for xmlns attributes
          if (
            node.parent &&
            node.parent.type === "JSXAttribute" &&
            node.parent.name &&
            node.parent.name.name === "xmlns"
          ) {
            // Do nothing
          } else if (
            matches(blocklist, node.value) &&
            !matches(exceptions, node.value) &&
            shouldFix(context, node)
          ) {
            context.report({
              node: node,
              messageId: "doNotUseInsecureUrl",
              fix(fixer) {
                let fixedString = node.value.replace("http://", "https://");
                //insert an "s" before ":/" to change http:/ to https:/
                return fixer.replaceText(node, `"${fixedString}"`);
              },
            });
          }
        }
      },
      TemplateElement(node) {
        if (skipUpcomingLines) {
          //Do Nothing
        }
        if (
          typeof node.value.raw === "string" &&
          typeof node.value.cooked === "string"
        ) {
          const rawStringText = node.value.raw;
          const cookedStringText = node.value.cooked;

          if (
            shouldFix(context, node) &&
            ((matches(blocklist, rawStringText) &&
              !matches(exceptions, rawStringText)) ||
              (matches(blocklist, cookedStringText) &&
                !matches(exceptions, cookedStringText)))
          ) {
            context.report({
              node: node,
              messageId: "doNotUseInsecureUrl",
              fix(fixer) {
                let fixedString = node.value.raw.replace("http://", "https://");
                //insert an "s" before ":/" to change http:/ to https:/
                return fixer.replaceText(node, `"${fixedString}"`);
              },
            });
          }
        }
      },
    };
  },
};
