/* eslint-disable object-shorthand */
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

/**
 * @fileoverview Disallows usage of insecure protocols in URL strings
 */

"use strict";

//const { check } = require("prettier");

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
const DEFAULT_BLOCKLIST = [/^(ftp|http|telnet|ws):\/\//i];

const DEFAULT_EXCEPTIONS = [
  // TODO: add more typical false positives such as XML schemas after more testing
  /^http:(\/\/|\\u002f\\u002f)schemas\.microsoft\.com(\/\/|\\u002f\\u002f)?.*/i,
  /^http:(\/\/|\\u002f\\u002f)schemas\.openxmlformats\.org(\/\/|\\u002f\\u002f)?.*/i,
  /^http:(\/|\\u002f){2}localhost(:|\/|\\u002f)*/i,
];
// Flag that exempts file from warnings
let skipUpcomingLines = false;

// If one of the first comments in the file indicates that the files shouldn't be changed.
// skip the upcoming lines.
function checkFirstComments(context) {
  let sourceCode = context.getSourceCode();
  // Get all comments and save them as a String
  const allComments = sourceCode.getAllComments();
  console.log("CALLED");
  for (let i = 0; i < allComments.length && i < 10; i++) {
    console.log("IN THE LOOP");
    let comment = sourceCode.getText(allComments[i]).toUpperCase();
    // Check if file was auto-generated and exempt it for fixes. That is a temporary solution.
    if (
      allComments.length > 0 &&
      (comment.includes("DO NOT MODIFY") ||
        comment.includes("AUTOGENERATED") ||
        comment.includes("AUTO-GENERATED"))
    ) {
      console.log("should skip");
      return true;
    }
  }
  return false;
}

function shouldFix(context, node) {
  let sourceCode = context.getSourceCode();
  const text = node.parent
    ? sourceCode.getText(node.parent)
    : sourceCode.getText(node);
  // Get comments that are directly before line
  const commentsBefore = sourceCode.getCommentsBefore(node);
  // doesn√Ñt work yet
  for (let i = 0; i < commentsBefore.length; i++) {
    let comment = sourceCode.getText(commentsBefore[i]).toUpperCase();
    // Check if line was auto-generated and exempt it for fixes. That is a temporary solution
    if (
      commentsBefore.length > 0 &&
      (comment.includes("DO NOT MODIFY") ||
        comment.includes("AUTOGENERATED") ||
        comment.includes("AUTO-GENERATED"))
    ) {
      return false;
    }
  }
  const unfixablePattern = ["insecure", "Insecure", "xmlns"];
  // eslint-disable-next-line consistent-return
  for (let index = 0; index < unfixablePattern.length; index++) {
    const element = unfixablePattern[index];
    if (text.includes(element)) {
      return false;
    }
  }
  return true;
}

module.exports = {
  defaultBlocklist: DEFAULT_BLOCKLIST,
  defaultExceptions: DEFAULT_EXCEPTIONS,
  meta: {
    type: "suggestion",
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          blocklist: {
            type: "array",
            items: {
              type: "string",
            },
          },
          exceptions: {
            type: "array",
            items: {
              type: "string",
            },
          },
        },
        additionalProperties: false,
      },
    ],
    docs: {
      category: "Security",
      description:
        "Insecure protocols such as [HTTP](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) or [FTP](https://en.wikipedia.org/wiki/File_Transfer_Protocol) should be replaced by their encrypted counterparts ([HTTPS](https://en.wikipedia.org/wiki/HTTPS), [FTPS](https://en.wikipedia.org/wiki/FTPS)) to avoid sending (potentially sensitive) data over untrusted network in plaintext.",
      url:
        "https://github.com/microsoft/eslint-plugin-sdl/blob/master/docs/rules/no-insecure-url.md",
    },
    messages: {
      doNotUseInsecureUrl: "Do not use insecure URLs",
    },
  },
  create: function(context) {
    const options = context.options[0] || {};
    const blocklist = (options.blocklist || DEFAULT_BLOCKLIST).map(pattern => {
      return new RegExp(pattern, "i");
    });
    const exceptions = (options.exceptions || DEFAULT_EXCEPTIONS).map(
      pattern => {
        return new RegExp(pattern, "i");
      }
    );
    // Check first ten comments and set flag if needed
    skipUpcomingLines = checkFirstComments(context);
    function matches(patterns, value) {
      return (
        patterns.find(re => {
          return re.test(value);
        }) !== undefined
      );
    }

    return {
      Literal(node) {
        if (skipUpcomingLines) {
          //Do Nothing
          console.log("Skippi skippi du");
        } else if (typeof node.value === "string") {
          // Add an exception for xmlns attributes
          if (
            node.parent &&
            node.parent.type === "JSXAttribute" &&
            node.parent.name &&
            node.parent.name.name === "xmlns"
          ) {
            // Do nothing
          } else if (
            matches(blocklist, node.value) &&
            !matches(exceptions, node.value) &&
            shouldFix(context, node)
          ) {
            context.report({
              node: node,
              messageId: "doNotUseInsecureUrl",
              // eslint-disable-next-line consistent-return
              fix(fixer) {
                // eslint-disable-next-line mozilla/no-insecure-url
                let fixedString = node.value.replace("http://", "https://");
                //insert an "s" before ":/" to change http:/ to https:/
                return fixer.replaceText(node, `"${fixedString}"`);
              },
            });
          }
        }
      },
      TemplateElement(node) {
        if (skipUpcomingLines) {
          //Do Nothing
        }
        if (
          typeof node.value.raw === "string" &&
          typeof node.value.cooked === "string"
        ) {
          const rawStringText = node.value.raw;
          const cookedStringText = node.value.cooked;

          if (
            shouldFix(context, node) &&
            ((matches(blocklist, rawStringText) &&
              !matches(exceptions, rawStringText)) ||
              (matches(blocklist, cookedStringText) &&
                !matches(exceptions, cookedStringText)))
          ) {
            context.report({
              node: node,
              messageId: "doNotUseInsecureUrl",
              // eslint-disable-next-line consistent-return
              fix(fixer) {
                // eslint-disable-next-line mozilla/no-insecure-url
                let fixedString = node.value.raw.replace("http://", "https://");
                //insert an "s" before ":/" to change http:/ to https:/
                return fixer.replaceText(node, `"${fixedString}"`);
              },
            });
          }
        }
      },
    };
  },
};
